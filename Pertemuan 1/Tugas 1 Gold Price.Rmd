---
title: "Tugas Pertemuan 2 - Pemulusan"
author: Dewi Astinasari
output:
  html_document: default
  pdf_document: default
  word_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Library / Packages

```{r}
library("forecast")
library("graphics")
library("TTR")
library("TSA")
```

## Impor Data

```{r}
library(rio)
data1 <- import("C:/Users/62851/Documents/gold2.xlsx")
data1
```

## Eksplorasi Data

```{r}
str(data1)
dim(data1)
```

Mengubah data agar terbaca sebagai data deret waktu dengan fungsi `ts()` .

```{r}
data1.ts <- ts(data1$Price)
```


```{r}
summary(data1.ts)
```

```{r}
dates <- as.Date(data1$Date)

plot(data1.ts, xaxt="n", xlab="Time Period", ylab="Price", main="Gold Price per Day")
points(data1.ts, pch=1)

months_idx <- which(format(dates, "%d") == "01")
axis(1, at=time(data1.ts)[months_idx], labels=format(dates[months_idx], "%b-%Y"))
```
Plot deret waktu harga emas menunjukkan pola tren karena kecenderungan naik secara bertahap dengan satu kali penurunan tajam dan tidak terlihat adanya pola berulang secara periodik. 

Pola siklis biasanya terjadi pada jangka panjang dengan pengulangan teratur mengikuti siklus ekonomi atau musim. Sedangkan data emas ini lebih ke arah tren jangka pendek (100 hari) yang berfluktuasi tapi arahnya tetap meningkat.


## Double Moving Average
### Pembagian Data

Pembagian data latih dan data uji dilakukan dengan perbandingan 80% data latih dan 20% data uji.

```{r}
#membagi data latih dan data uji
training_ma <- data1[1:80,]
testing_ma <- data1[81:100,]
train_ma.ts <- ts(training_ma$Price)
test_ma.ts <- ts(testing_ma$Price)
```

### Eksplorasi Data

```{r}
#eksplorasi keseluruhan data
plot(data1.ts, col="red",main="Plot semua data")
points(data1.ts)

#eksplorasi data latih
plot(train_ma.ts, col="blue",main="Plot data latih")
points(train_ma.ts)

#eksplorasi data uji
plot(test_ma.ts, col="blue",main="Plot data uji")
points(test_ma.ts)
```

```{r}
#Eksplorasi dengan GGPLOT
library(ggplot2)
ggplot() + 
  geom_line(data = training_ma, aes(x = Date, y = Price, col = "Data Latih")) +
  geom_line(data = testing_ma, aes(x = Date, y = Price, col = "Data Uji")) +
  labs(x = "Periode Waktu", y = "Price", color = "Legend") +
  scale_colour_manual(name="Keterangan:", breaks = c("Data Latih", "Data Uji"),
                      values = c("blue", "red")) + 
  theme_bw() + theme(legend.position = "bottom",
                     plot.caption = element_text(hjust=0.5, size=12))
```

```{r}
data.sma<-SMA(train_ma.ts, n=4)
data.sma
```

```{r}
dma <- SMA(data.sma, n = 4)
At <- 2*data.sma - dma
Bt <- 2/(4-1)*(data.sma - dma)
data.dma<- At+Bt
data.ramal2<- c(NA, data.dma)

t = 1:20
f = c()

for (i in t) {
  f[i] = At[length(At)] + Bt[length(Bt)]*(i)
}

data.gab2 <- cbind(aktual = c(train_ma.ts,rep(NA,20)), pemulusan1 = c(data.sma,rep(NA,20)),pemulusan2 = c(data.dma, rep(NA,20)),At = c(At, rep(NA,20)), Bt = c(Bt,rep(NA,20)),ramalan = c(data.ramal2, f[-1]))
data.gab2
```


```{r}
ts.plot(data1.ts, xlab="Time Period ", ylab="Price", main= "DMA N=4 Gold Price")
points(data1.ts)
lines(data.gab2[,3],col="green",lwd=2)
lines(data.gab2[,6],col="red",lwd=2)
legend("topleft",c("data aktual","data pemulusan","data peramalan"), lty=8, col=c("black","green","red"), cex=0.8)
```


```{r}
#Menghitung nilai keakuratan data latih
error_train.dma = train_ma.ts-data.ramal2[1:length(train_ma.ts)]
SSE_train.dma = sum(error_train.dma[8:length(train_ma.ts)]^2)
MSE_train.dma = mean(error_train.dma[8:length(train_ma.ts)]^2)
MAPE_train.dma = mean(abs((error_train.dma[8:length(train_ma.ts)]/train_ma.ts[8:length(train_ma.ts)])*100))

akurasi_train.dma <- matrix(c(SSE_train.dma, MSE_train.dma, MAPE_train.dma))
row.names(akurasi_train.dma)<- c("SSE", "MSE", "MAPE")
colnames(akurasi_train.dma) <- c("Akurasi m = 4")
akurasi_train.dma
```

Perhitungan akurasi pada data latih menggunakan nilai MAPE menghasilkan nilai MAPE 0.486% yang kurang dari 10%, sehingga dikategorikan sangat baik.

```{r}
#Menghitung nilai keakuratan data uji
error_test.dma = test_ma.ts-data.gab2[81:100,6]
SSE_test.dma = sum(error_test.dma^2)
MSE_test.dma = mean(error_test.dma^2)
MAPE_test.dma = mean(abs((error_test.dma/test_ma.ts*100)))

akurasi_test.dma <- matrix(c(SSE_test.dma, MSE_test.dma, MAPE_test.dma))
row.names(akurasi_test.dma)<- c("SSE", "MSE", "MAPE")
colnames(akurasi_test.dma) <- c("Akurasi m = 4")
akurasi_test.dma
```

Perhitungan akurasi menggunakan data uji menghasilkan nilai MAPE 4.998% yang kurang dari 10% sehingga nilai akurasi ini dapat dikategorikan sebagai sangat baik.


## Double Exponential Smoothing
### Pembagian Data

Pembagian data latih dan data uji dilakukan dengan perbandingan 80% data latih dan 20% data uji.

```{r}
#membagi training dan testing
training<-data1[1:80,]
testing<-data1[81:100,]
train.ts <- ts(training$Price)
test.ts <- ts(testing$Price)
```

### Eksplorasi

```{r}
#eksplorasi data
plot(data1.ts, col="black",main="Plot semua data")
points(data1.ts)

plot(train.ts, col="red",main="Plot data latih")
points(train.ts)

plot(test.ts, col="blue",main="Plot data uji")
points(test.ts)
```

```{r}
#Lamda=0.2 dan gamma=0.2
des.1<- HoltWinters(train.ts, gamma = FALSE, beta = 0.2, alpha = 0.2)
plot(des.1)

#ramalan
ramalandes1<- forecast(des.1, h=20)
ramalandes1

#Lamda=0.6 dan gamma=0.3
des.2<- HoltWinters(train.ts, gamma = FALSE, beta = 0.3, alpha = 0.6)
plot(des.2)

#ramalan
ramalandes2<- forecast(des.2, h=20)
ramalandes2
```

```{r}
plot(data1.ts)
lines(des.1$fitted[,1], lty=2, col="blue")
lines(ramalandes1$mean, col="red")
```


```{r}
#Lamda dan gamma optimum
des.opt<- HoltWinters(train.ts, gamma = FALSE)
des.opt
plot(des.opt)

#ramalan
ramalandesopt<- forecast(des.opt, h=20)
ramalandesopt
```

#### Akurasi Data Latih

```{r}
#Akurasi Data Training
ssedes.train1<-des.1$SSE
msedes.train1<-ssedes.train1/length(train.ts)
sisaandes1<-ramalandes1$residuals
head(sisaandes1)

mapedes.train1 <- sum(abs(sisaandes1[3:length(train.ts)]/train.ts[3:length(train.ts)])
                      *100)/length(train.ts)

akurasides.1 <- matrix(c(ssedes.train1,msedes.train1,mapedes.train1))
row.names(akurasides.1)<- c("SSE", "MSE", "MAPE")
colnames(akurasides.1) <- c("Akurasi lamda=0.2 dan gamma=0.2")
akurasides.1

ssedes.train2<-des.2$SSE
msedes.train2<-ssedes.train2/length(train.ts)
sisaandes2<-ramalandes2$residuals
head(sisaandes2)

mapedes.train2 <- sum(abs(sisaandes2[3:length(train.ts)]/train.ts[3:length(train.ts)])
                      *100)/length(train.ts)

akurasides.2 <- matrix(c(ssedes.train2,msedes.train2,mapedes.train2))
row.names(akurasides.2)<- c("SSE", "MSE", "MAPE")
colnames(akurasides.2) <- c("Akurasi lamda=0.6 dan gamma=0.3")
akurasides.2
```

Meskipun kedua model DES menunjukkan kinerja yang sangat baik pada data latih, skenario 2 adalah yang paling optimal karena memiliki nilai MAPE yang lebih kecil (0.418%), yang berarti modelnya mampu mereplikasi pola data historis dengan lebih akurat.


#### Akurasi Data Uji

```{r}
#Akurasi Data Testing
selisihdes1<-ramalandes1$mean-testing$Price
selisihdes1

SSEtestingdes1<-sum(selisihdes1^2)
MSEtestingdes1<-SSEtestingdes1/length(testing$Price)
MAPEtestingdes1<-sum(abs(selisihdes1/testing$Price)*100)/length(testing$Price)

selisihdes2<-ramalandes2$mean-testing$Price
selisihdes2

SSEtestingdes2<-sum(selisihdes2^2)
MSEtestingdes2<-SSEtestingdes2/length(testing$Price)
MAPEtestingdes2<-sum(abs(selisihdes2/testing$Price)*100)/length(testing$Price)

selisihdesopt<-ramalandesopt$mean-testing$Price
selisihdesopt

SSEtestingdesopt<-sum(selisihdesopt^2)
MSEtestingdesopt<-SSEtestingdesopt/length(testing$Price)
MAPEtestingdesopt<-sum(abs(selisihdesopt/testing$Price)*100)/length(testing$Price)

akurasitestingdes <-
  matrix(c(SSEtestingdes1,MSEtestingdes1,MAPEtestingdes1,SSEtestingdes2,MSEtestingdes2,
           MAPEtestingdes2,SSEtestingdesopt,MSEtestingdesopt,MAPEtestingdesopt),
         nrow=3,ncol=3)
row.names(akurasitestingdes)<- c("SSE", "MSE", "MAPE")
colnames(akurasitestingdes) <- c("des ske1","des ske2","des opt")
akurasitestingdes
```

Secara keseluruhan, model DES skenario optimal memberikan peramalan terbaik untuk data uji dengan nilai MAPE 3.90%


## Kesimpulan
Berdasarkan hasil interpretasi yang telah diberikan, metode Double Exponential Smoothing (DES) adalah yang paling direkomendasikan untuk digunakan.

Nilai MAPE yang lebih rendah pada metode DES menunjukkan bahwa model ini memiliki tingkat akurasi peramalan yang lebih tinggi dibandingkan dengan metode DMA. Meskipun kedua hasil tergolong "sangat baik" (MAPE < 10%), DES secara konsisten memberikan perkiraan yang lebih mendekati nilai aktual.

